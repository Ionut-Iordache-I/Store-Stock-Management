# Store-Stock-Management

The theme is the implementation of a program with which a store can be managed.
 The input data that I will retrieve from a CSV file are: uniq-id (unique product ID), product_name (product name), manufacturer (manufacturer name), price (product price) and number_available_in_stock (product quantity).
 For the implementation of this program I used several classes with a well-defined role to comply with the Single Responsibility Principle (SRP), such as:The Store class where I needed an ArrayList to store the Product objects that represented the various products I was adding to my store. I did the same thing to store the coins that the store accepts at a certain time, as well as to store the list of discounts that I had for that store.
 To retain the manufacturers that came with the products I added to the store, I used a HashSet to add them once because I didn't need duplicates for them.
 In order to have an initial currency in which the store can take orders and place orders, I considered the initial currency, the euro with the corresponding symbol and the corresponding parity (1.0), parameters that I gave to the builder of such a currency object.
 To make sure that only one instance of the class will be created, I used a Singletone as a design pattern. In this class I did the reading from the CSV file using the suggestive method readCSV () in which I treated cases such as the lack of price of a product or the price of 0.0 and the absence of the sign "Â£" in front of the string referring to price, which causes it to be ignored for addition to the store. 
 To create an object like Product it was necessary to implement the Builder design pattern to manage the significant number of parameters of this class and avoid losing the immutable property. In case you tried to add a new manufacturer, the DuplicateManufacturerException exception was caught, also if you tried to add a product with the same uniq_id in the store, the DuplicateProductException exception was caught in this function.
 To display the existing products in the store in CSV format, I created the saveCSV () method, which takes care of this.
Other methods that make up the Store class are addProduct () which adds a product to the store's product list if it is not already there, using uniq_id as the identifier. The method throws the DuplicateProductException exception and also adds the corresponding to the product if it does not already exist.
 For the addManufacturer () method I threw the DuplicateManufacturerException exception if when trying to add a manufacturer it already exists in the HashSet.
To change the currency in which the transactions are made in the store, we needed the changeCurrency () method, which first searches the list of currencies added in the store and if it was not found, we throw the CurrencyNotFoundException exception. If, however, we found the currency in this list, we recalculated the price of the products using the recalculatedPrice () method within the Product class.
 In order to further extend the functionalities of this program, I decided to add various discounts on its products for the products belonging to the store. First we create a discount using the createDiscunt () method, after which we had the opportunity to apply an already created discount that is in the discount list, and for this we used the applyDiscount () method which first verifies the membership of the discount we wanted to apply it to the discount list because if this discount is not in the list we throw the  DiscountNotFoundException exception. Also, if a negative price was obtained after applying a discount, the NegativePriceException exception is thrown and no product benefits from the discount received as a parameter to the method.
 The Product class contains attributes such as id, name, manufacturer, price, quantity and discount that were modified using specific getter and setter methods.The Manufacturer class also contains the name and countProducts attributes that determine the number of manufacturers, the method I call for each manufacturer added to the store.
For the discount types we used an enum that contains FIXED_DISCOUNT and PERCENTAGE_DISCOUNT.
In order to be able to perform the operations mentioned above, I chose to use a switch in which I have various commands that once applied, use the previously implemented methods.  Commands that do not have all the parameters that must be specified for a given command will throw the WrongNumberParametersException exception.
